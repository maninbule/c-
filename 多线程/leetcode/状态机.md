
力扣：1117. H2O 生成

| 状态 | 产生氢气 | 产生氧气 |
|--------|--------|--------|
| O {}   | 1   | 2   |
| 1 {H}  | 3   | 4   |
| 2 {O}  | 5  | -1|
| 3 {HH} | -1  | 0|
| 4 {HO} | 0 | -1|
| 5 {OH} | 0 | -1|
根据上表构造一个状态机，第一列代表线程执行顺序状态，第二三列代表状态转移方程。
注意表中的 WAIT，这代表此时线程应被阻塞。
当从 3、4 状态转移回 0 状态时，唤醒所有被阻塞的线程。

参考：
https://leetcode.cn/problems/building-h2o/solutions/1637825/shengchengzhe-by-lyon-f-0rs9/

```cpp
class H2O {
private:
    std::condition_variable cv;
    std::mutex mtx;
    int state = 0;
    int transitions[6][2] = {{1,2},{3,4},{5,-1},{-1,0},{0,-1},{0,-1}};
public:
    H2O() {
        
    }

    void hydrogen(function<void()> releaseHydrogen) {
        // releaseHydrogen() outputs "H". Do not change or remove this line.
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock,[this]{
            return transitions[state][0] != -1;
        });
        state = transitions[state][0];
        releaseHydrogen();
        if(state == 0) cv.notify_all();
    }

    void oxygen(function<void()> releaseOxygen) {
        // releaseOxygen() outputs "O". Do not change or remove this line.
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock,[this]{
            return transitions[state][1] != -1;
        });
        state = transitions[state][1];
        releaseOxygen();
        if(state == 0) cv.notify_all();
    }
};
```
