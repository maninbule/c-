# 编译规则
**一个 Makefile 文件中可以有一个或者多个规则**  
```
目标 ...: 依赖 ...  
  命令（Shell 命令）  
  ...  
```
  ⚫ 目标：最终要生成的文件（伪目标除外）  
  ⚫ 依赖：生成目标所需要的文件或是目标  
  ⚫ 命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进）  
**Makefile 中的其它规则一般都是为第一条规则服务的**
如果命令中有某个依赖目前不存在，那么就会执行后面的规则，等依赖都准备好了之后，再进行编译或链接  
这个原理类似于有向无环图  
另外，对于与第一条规则无关的规则，会被跳过，不会被执行，可以理解为与这个有向无环图无关的点，不会被访问

**在makefile执行之前，会对比目标文件和依赖文件的时间，如果依赖的时间晚于目标文件，则会重新执行编译，否则不会**
# 以编译calc文件为例
## 简洁版本
在calc目录中添加Makefile文件，写上如下内容
```
app: add.c div.c main.c mult.c sub.c
	gcc -o app add.c div.c main.c mult.c sub.c
```
在本目录输入make，就会自动编译了，编译之后产生可执行的程序app

## 复杂的版本
```
app: add.o div.o main.o mult.o sub.o
	gcc -o app add.o div.o main.o mult.o sub.o
add.o: add.c
	gcc -o add.o -c add.c
div.o:div.c
	gcc -o div.o -c div.c
mult.o:mult.c
	gcc -o mult.o -c mult.c
sub.o: sub.c
	gcc -o sub.o -c sub.c
main.o:main.c
	gcc -o main.o -c main.c
```
**两个版本的区别**  
第一个版本如果某个源文件发生了变化，则会执行`gcc -o app add.o div.o main.o mult.o sub.o`, 会把其他的源代码文件都要重新编译一边  
第二个版本如果某个源代码文件发生了变化，则只会改变对于的目标.o文件，其他的目标文件不会重新生成，之后再重新链接一下即可，效率更高  

# makefile变量的使用
**自定义变量**  
	`变量名=变量值 var=hello`   
**预定义变量**  
```
	AR : 归档维护程序的名称，默认值为 ar  
	CC : C 编译器的名称，默认值为 cc  ---默认就是gcc
	CXX : C++ 编译器的名称，默认值为 g++  
	$@ : 目标的完整名称  
	$< : 第一个依赖文件的名称  
	$^ : 所有的依赖文件  
```
**获取变量的值**  
	`$(变量名)`  
