# 进程退出
```c
#include <stdlib.h>
void exit(int status); -----------c语言的退出


#include <unistd.h>
void _exit(int status); ----------------unix的进程退出
```
**不同点**： exit会在退出之前主动刷新I/O缓冲区，保证写入/读入完整,_exit()不会主动刷新

# 孤儿进程
子进程结束的时候，发现父进程已经结束了，就被init进程托管了，这个子进程就被称为孤儿进程 

◼ 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。  
◼ 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。  
◼ 因此孤儿进程并不会有什么危害。  
**示例**
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main(){
    pid_t pid = fork();
    if(pid > 0){
        printf("father process: pid = %d ppid = %d\n",getpid(),getppid());
    }else if(pid == 0){
        sleep(1);
        printf("father process: pid = %d ppid = %d\n",getpid(),getppid());
    }
    return 0;
}
```
**输出**
```
leo@leo-virtual-machine:~/linux/process/exit$ ./orphan 
father process: pid = 3540 ppid = 3452
leo@leo-virtual-machine:~/linux/process/exit$ father process: pid = 3541 ppid = 1  
  ----因为父进程在后台运行结束了，所以会自动跳到前台
```
可以看到子进程的ppid变成了1，说明他的父进程变成了init进程



# 僵尸进程
子进程结束了，父进程没有结束，但是父进程就是不回收子进程的内核区

◼ 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。  
◼ 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。  
◼ 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。  
**示例**
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main(){
    pid_t pid = fork();
    if(pid > 0){
        printf("father process: pid = %d ppid = %d\n",getpid(),getppid());
        while(1);
    }else if(pid == 0){
        printf("father process: pid = %d ppid = %d\n",getpid(),getppid());
    }
    return 0;
}
```
在ps aux可以看到
```
leo        3573 95.4  0.0   4516   748 pts/1    R+   11:57   0:08 ./zombie
leo        3574  0.0  0.0      0     0 pts/1    Z+   11:57   0:00 [zombie] <defunct>
```
就是因为子进程结束了，父进程一直在循环，没去回收子进程  
当我们强制结束父进程，再看ps aux就可以发现没有僵尸进程了  

