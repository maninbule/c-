# 进程退出
```c
#include <stdlib.h>
void exit(int status); -----------c语言的退出


#include <unistd.h>
void _exit(int status); ----------------unix的进程退出
```
**不同点**： exit会在退出之前主动刷新I/O缓冲区，保证写入/读入完整,_exit()不会主动刷新

# 孤儿进程
子进程结束的时候，发现父进程已经结束了，就被init进程托管了，这个子进程就被称为孤儿进程 

◼ 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。  
◼ 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。  
◼ 因此孤儿进程并不会有什么危害。  
**示例**
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main(){
    pid_t pid = fork();
    if(pid > 0){
        printf("father process: pid = %d ppid = %d\n",getpid(),getppid());
    }else if(pid == 0){
        sleep(1);
        printf("father process: pid = %d ppid = %d\n",getpid(),getppid());
    }
    return 0;
}
```
**输出**
```
leo@leo-virtual-machine:~/linux/process/exit$ ./orphan 
father process: pid = 3540 ppid = 3452
leo@leo-virtual-machine:~/linux/process/exit$ father process: pid = 3541 ppid = 1  
  ----因为父进程在后台运行结束了，所以会自动跳到前台
```
可以看到子进程的ppid变成了1，说明他的父进程变成了init进程



# 僵尸进程
子进程结束了，父进程没有结束，但是父进程就是不回收子进程的内核区

◼ 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。  
◼ 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。  
◼ 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。  
**示例**
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>

int main(){
    pid_t pid = fork();
    if(pid > 0){
        printf("father process: pid = %d ppid = %d\n",getpid(),getppid());
        while(1);
    }else if(pid == 0){
        printf("father process: pid = %d ppid = %d\n",getpid(),getppid());
    }
    return 0;
}
```
在ps aux可以看到
```
leo        3573 95.4  0.0   4516   748 pts/1    R+   11:57   0:08 ./zombie
leo        3574  0.0  0.0      0     0 pts/1    Z+   11:57   0:00 [zombie] <defunct>
```
就是因为子进程结束了，父进程一直在循环，没去回收子进程  
当我们强制结束父进程，再看ps aux就可以发现没有僵尸进程了  
# 等待进程
让父进程等待子进程的退出
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *wstatus);
    功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。
    参数：int *wstatus
        进程退出时的状态信息，传入的是一个int类型的地址，传出参数。
    返回值：
        - 成功：返回被回收的子进程的id
        - 失败：-1 (所有的子进程都结束，调用函数失败)

调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）
如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.
```
**状态相关函数宏**
◼ WIFEXITED(status) 非0，进程正常退出  
◼ WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）  

◼ WIFSIGNALED(status) 非0，进程异常终止  
◼ WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号  

◼ WIFSTOPPED(status) 非0，进程处于暂停状态  
◼ WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号  

◼ WIFCONTINUED(status) 非0，进程暂停后已经继续运行  

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

int main(){
    pid_t pid = fork();
    if(pid > 0){
        printf("father process: pid = %d, ppid = %d\n",getpid(),getppid());
        while(1){
            int st;
            pid_t pid = wait(&st); //等待的时候，父进程阻塞，直到某个子进程的状态改变了才唤醒
            if(pid == -1){
                break;
            }
            if(WIFEXITED(st)){
                printf("子进程退出的状态编号是：%d\n",WEXITSTATUS(st));
            }
            if(WIFSIGNALED(st)){
                //在终端中用kill 9 child_pid就来退出子进程
                printf("导致子进程退出的信号为：%d\n",WTERMSIG(st));
            }
        }
    }else{
        while(1){
            printf("child process: pid = %d, ppid = %d\n",getpid(),getppid());
            sleep(1);
        }
        exit(0);
    }



    return 0;
}
```

